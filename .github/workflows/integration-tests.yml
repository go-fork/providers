name: Integration Tests

on:
  push:
    branches: [ main ]
    paths:
      - '**.go'
      - '**/go.mod'
      - '.github/workflows/integration-tests.yml'
  schedule:
    - cron: '0 2 * * 1' # Run at 2 AM UTC every Monday
  workflow_dispatch:

jobs:
  integration-test:
    name: Integration Tests
    runs-on: ubuntu-latest
    services:
      # Add Redis service
      redis:
        image: redis:alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      # Add MongoDB service
      mongodb:
        image: mongo:5
        ports:
          - 27017:27017
        env:
          MONGO_INITDB_ROOT_USERNAME: root
          MONGO_INITDB_ROOT_PASSWORD: example
        options: >-
          --health-cmd "mongosh --eval 'db.runCommand({ping: 1})'"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.23.x'
          cache: true
      
      - name: Create integration test environment
        run: |
          # Create a main module for integration tests
          mkdir -p integration-tests
          cd integration-tests
          
          # Initialize Go module
          go mod init github.com/go-fork/providers/integration-tests
          
          # Add references to local modules
          echo "replace github.com/go-fork/providers/cache => ../cache" >> go.mod
          echo "replace github.com/go-fork/providers/log => ../log" >> go.mod
          echo "replace github.com/go-fork/providers/http => ../http" >> go.mod
          echo "replace github.com/go-fork/providers/config => ../config" >> go.mod
          echo "replace github.com/go-fork/providers/middleware => ../middleware" >> go.mod
          
          # Add local dependencies
          echo "require (" >> go.mod
          echo "  github.com/go-fork/providers/cache v0.0.0" >> go.mod
          echo "  github.com/go-fork/providers/log v0.0.0" >> go.mod
          echo "  github.com/go-fork/providers/http v0.0.0" >> go.mod
          echo "  github.com/go-fork/providers/config v0.0.0" >> go.mod
          echo "  github.com/go-fork/providers/middleware v0.0.0" >> go.mod
          echo ")" >> go.mod
          
          go mod tidy
      
      - name: Create integration tests
        run: |
          cd integration-tests
          
          # Create test configuration
          mkdir -p testdata
          cat > testdata/test_config.yaml << EOF
          app:
            name: integration-test
            debug: true
          
          cache:
            driver: redis
            redis:
              host: localhost
              port: 6379
              db: 0
          
          log:
            level: debug
            format: json
            output: stdout
          
          http:
            host: localhost
            port: 8080
          
          mongodb:
            uri: mongodb://root:example@localhost:27017
            database: test
          EOF
          
          # Create a cache integration test
          cat > cache_integration_test.go << EOF
          package integration_test
          
          import (
            "context"
            "testing"
            "time"
          
            "github.com/go-fork/providers/cache"
            "github.com/go-fork/providers/config"
          )
          
          func TestCacheIntegration(t *testing.T) {
            // Skip if not running in CI environment
            if testing.Short() {
              t.Skip("Skipping integration test in short mode")
            }
            
            // Load config
            cfg, err := config.NewManager().
              AddPath("testdata").
              AddFile("test_config.yaml").
              Load()
            
            if err != nil {
              t.Fatalf("Failed to load config: %v", err)
            }
            
            // Create cache manager
            cacheManager, err := cache.NewManager().
              WithConfig(cfg).
              Build()
            
            if err != nil {
              t.Fatalf("Failed to create cache manager: %v", err)
            }
            
            // Test cache operations
            ctx := context.Background()
            key := "test-key"
            value := "test-value"
            
            // Set value
            err = cacheManager.Set(ctx, key, value, 1*time.Minute)
            if err != nil {
              t.Fatalf("Failed to set cache: %v", err)
            }
            
            // Get value
            var result string
            exists, err := cacheManager.Get(ctx, key, &result)
            if err != nil {
              t.Fatalf("Failed to get from cache: %v", err)
            }
            
            if !exists {
              t.Fatalf("Expected key to exist")
            }
            
            if result != value {
              t.Fatalf("Expected %s, got %s", value, result)
            }
            
            // Delete value
            err = cacheManager.Delete(ctx, key)
            if err != nil {
              t.Fatalf("Failed to delete from cache: %v", err)
            }
            
            // Verify deleted
            exists, err = cacheManager.Get(ctx, key, &result)
            if err != nil {
              t.Fatalf("Failed to get from cache: %v", err)
            }
            
            if exists {
              t.Fatalf("Expected key to be deleted")
            }
          }
          EOF
          
          # Create an HTTP integration test
          cat > http_integration_test.go << EOF
          package integration_test
          
          import (
            "net/http"
            "net/http/httptest"
            "testing"
          
            providersHttp "github.com/go-fork/providers/http"
            "github.com/go-fork/providers/middleware"
          )
          
          func TestHttpIntegration(t *testing.T) {
            // Skip if not running in CI environment
            if testing.Short() {
              t.Skip("Skipping integration test in short mode")
            }
            
            // Create router
            router := providersHttp.NewRouter()
            
            // Add middleware
            corsMiddleware := middleware.NewCors().
              AllowOrigins("*").
              AllowMethods("GET", "POST").
              Build()
            
            router.Use(corsMiddleware)
            
            // Add a route
            router.Get("/test", func(w http.ResponseWriter, r *http.Request) {
              w.WriteHeader(http.StatusOK)
              w.Write([]byte("Success"))
            })
            
            // Test request
            req := httptest.NewRequest("GET", "/test", nil)
            rr := httptest.NewRecorder()
            
            router.ServeHTTP(rr, req)
            
            // Check status code
            if status := rr.Code; status != http.StatusOK {
              t.Errorf("handler returned wrong status code: got %v want %v", status, http.StatusOK)
            }
            
            // Check response body
            expected := "Success"
            if rr.Body.String() != expected {
              t.Errorf("handler returned unexpected body: got %v want %v", rr.Body.String(), expected)
            }
            
            // Check CORS headers
            if rr.Header().Get("Access-Control-Allow-Origin") != "*" {
              t.Errorf("Expected CORS header Access-Control-Allow-Origin to be *, got %s", rr.Header().Get("Access-Control-Allow-Origin"))
            }
          }
          EOF
      
      - name: Run integration tests
        run: |
          cd integration-tests
          go test -v ./...
      
      - name: Generate integration test report
        if: always()
        run: |
          cd integration-tests
          go test -v -json ./... > test-report.json
      
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: integration-test-results
          path: integration-tests/test-report.json
