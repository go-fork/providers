name: Code Quality Analysis

on:
  push:
    branches: [ main ]
    paths:
      - '**.go'
      - '**/go.mod'
      - '.golangci.yml'
      - '.github/workflows/code-quality.yml'
  pull_request:
    branches: [ main ]
    paths:
      - '**.go'
      - '**/go.mod'
      - '.golangci.yml'
  workflow_dispatch:

jobs:
  advanced-lint:
    name: Advanced Linting
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.23.x'
          cache: true
      
      - name: Run staticcheck
        uses: dominikh/staticcheck-action@v1
        with:
          version: "latest"
          install-go: false
          min-go-version: "1.20"
      
      - name: Run golangci-lint with comprehensive checks
        uses: golangci/golangci-lint-action@v3
        with:
          version: v1.54
          args: >-
            --timeout=10m
            --enable=gocritic,gocognit,goconst,gocyclo,godot,gofmt,goimports,gosec,gosimple,govet,ineffassign,misspell,prealloc,revive,staticcheck,unconvert,unparam,unused
      
      - name: Run additional Go tools
        run: |
          go install honnef.co/go/tools/cmd/staticcheck@latest
          go install golang.org/x/tools/cmd/goimports@latest
          go install github.com/kisielk/errcheck@latest
          
          # List all modules
          MODULES=($(find . -name "go.mod" -exec dirname {} \; | sort))
          
          for mod_dir in "${MODULES[@]}"; do
            echo "Analyzing $mod_dir"
            cd "$mod_dir"
            
            # Check error handling
            echo "Running errcheck in $mod_dir"
            errcheck ./...
            
            # Check for optimizations with staticcheck
            echo "Running staticcheck in $mod_dir"
            staticcheck -checks=all ./...
            
            # Check code style with goimports
            echo "Running goimports in $mod_dir"
            goimports -d .
            
            cd - > /dev/null
          done
  
  complexity-analysis:
    name: Code Complexity Analysis
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.23.x'
          cache: true
      
      - name: Install complexity tools
        run: |
          go install github.com/fzipp/gocyclo/cmd/gocyclo@latest
          go install github.com/uudashr/gocognit/cmd/gocognit@latest
      
      - name: Analyze cyclomatic complexity
        run: |
          echo "Analyzing cyclomatic complexity..."
          COMPLEXITY_THRESHOLD=15
          
          # Check cyclomatic complexity
          HIGH_COMPLEXITY_FUNCS=$(gocyclo -over $COMPLEXITY_THRESHOLD .)
          
          if [ -n "$HIGH_COMPLEXITY_FUNCS" ]; then
            echo "⚠️ Functions with high cyclomatic complexity (over $COMPLEXITY_THRESHOLD):"
            echo "$HIGH_COMPLEXITY_FUNCS"
            echo ""
            echo "Consider refactoring these functions to reduce complexity."
          else
            echo "✅ No functions with high cyclomatic complexity found."
          fi
      
      - name: Analyze cognitive complexity
        run: |
          echo "Analyzing cognitive complexity..."
          COGNITIVE_THRESHOLD=20
          
          # Check cognitive complexity
          HIGH_COGNITIVE_FUNCS=$(gocognit -over $COGNITIVE_THRESHOLD .)
          
          if [ -n "$HIGH_COGNITIVE_FUNCS" ]; then
            echo "⚠️ Functions with high cognitive complexity (over $COGNITIVE_THRESHOLD):"
            echo "$HIGH_COGNITIVE_FUNCS"
            echo ""
            echo "Consider refactoring these functions to improve readability."
          else
            echo "✅ No functions with high cognitive complexity found."
          fi
  
  code-coverage:
    name: Code Coverage Analysis
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.23.x'
          cache: true
      
      - name: Calculate test coverage for each module
        run: |
          mkdir -p coverage-reports
          
          # Find all modules
          MODULES=($(find . -name "go.mod" -exec dirname {} \; | sort))
          
          # Overall stats
          TOTAL_COVERED=0
          TOTAL_STATEMENTS=0
          
          for mod_dir in "${MODULES[@]}"; do
            echo "Calculating coverage for $mod_dir"
            cd "$mod_dir"
            
            # Generate coverage report
            go test -coverprofile=coverage.out ./...
            
            if [ -f coverage.out ]; then
              # Create HTML report
              go tool cover -html=coverage.out -o coverage.html
              
              # Get coverage percentage
              COVERAGE=$(go tool cover -func=coverage.out | grep total | awk '{print $3}')
              echo "$mod_dir coverage: $COVERAGE"
              
              # Extract covered and total statements for aggregation
              STATS=$(go tool cover -func=coverage.out | grep total)
              COVERED=$(echo $STATS | awk '{print $3}' | sed 's/%//')
              STATEMENTS=$(echo $STATS | awk '{print $2}' | sed 's/(//' | sed 's/)//')
              
              # Add to totals
              TOTAL_COVERED=$(echo "$TOTAL_COVERED + ($COVERED * $STATEMENTS / 100)" | bc)
              TOTAL_STATEMENTS=$(echo "$TOTAL_STATEMENTS + $STATEMENTS" | bc)
              
              # Copy reports to centralized location
              cp coverage.out ../coverage-reports/$(basename "$mod_dir").coverage.out
              cp coverage.html ../coverage-reports/$(basename "$mod_dir").coverage.html
            else
              echo "No coverage data generated for $mod_dir"
            fi
            
            cd - > /dev/null
          done
          
          # Calculate overall coverage
          if [ $TOTAL_STATEMENTS -gt 0 ]; then
            OVERALL_COVERAGE=$(echo "scale=2; $TOTAL_COVERED * 100 / $TOTAL_STATEMENTS" | bc)
            echo "Overall coverage: $OVERALL_COVERAGE%"
            
            # Set threshold
            COVERAGE_THRESHOLD=70
            
            if (( $(echo "$OVERALL_COVERAGE < $COVERAGE_THRESHOLD" | bc -l) )); then
              echo "⚠️ WARNING: Coverage below target of $COVERAGE_THRESHOLD%"
            else
              echo "✅ Coverage meets or exceeds target of $COVERAGE_THRESHOLD%"
            fi
          else
            echo "No statements found for coverage calculation"
          fi
      
      - name: Upload coverage reports
        uses: actions/upload-artifact@v3
        with:
          name: coverage-reports
          path: coverage-reports/
      
      - name: Upload to codecov
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage-reports/*.coverage.out
          flags: unittests
          name: codecov-umbrella
